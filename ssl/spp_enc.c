#include <stdio.h>
#include "ssl_locl.h"
#ifndef OPENSSL_NO_COMP
#include <openssl/comp.h>
#endif
#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <openssl/md5.h>
#include <openssl/rand.h>
#ifdef KSSL_DEBUG
#include <openssl/des.h>
#endif

int spp_enc(SSL *s, int send) {
    SPP_SLICE *slice;
    
    if (send) {
        slice = s->write_slice;
    } else {
        slice = s->read_slice;
    }
    // Error if a slice has not been specified for this encrypt/decrypt op
    if (slice == NULL) {
        SSLerr(SSL_F_SPP_ENC,SPP_R_MISSING_SLICE);
        return -1;
    }
    
    /* If we do not possess the encryption material for this slice, 
     * do not attempt to decrypt. Not Needed, see below. */
    //if (!slice->have_material) {
        /* Copy the still encrypted content to the correct location. */
    //    return 1;
    //}
    
    /* Pick the right slice, and encrypt with it. */
    /* If we do not have the encryption material, slice->enc_XXX_ctx should be null. 
     * In that case, tls1 applies the null cipher. */
    if (send) {
        s->enc_write_ctx = slice->enc_write_ctx;
    } else if (!send) {
        s->enc_read_ctx = slice->enc_read_ctx;
    }
    return tls1_enc(s, send);
}

int xor_array(unsigned char* dst, unsigned char* src1, unsigned char* src2, size_t len) {
    size_t i;
    for (i = 0; i < len; i++) {
        dst[i] = src1[i] ^ src2[i];
    }
    return 1;
}

int spp_init_slice_st(SSL *s, SPP_SLICE *slice) {
    const EVP_CIPHER *c;
    const EVP_MD *m;
    int is_exp,cl,k;
    unsigned char *key, *iv;
    
    is_exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
    c=s->s3->tmp.new_sym_enc;
    m=s->s3->tmp.new_hash;
    cl=EVP_CIPHER_key_length(c);
    k=EVP_CIPHER_iv_length(c);
    
    if (slice->read_access) {
        // Secret is computed by XORing the material generated by the client and server
        xor_array(slice->read_mat, slice->read_mat, slice->other_read_mat, EVP_MAX_KEY_LENGTH);
        key = &(slice->read_mat[0]);
        /* IV is same as key right now. */
        iv = &(slice->read_mat[0]);
        
        // Generate the encryption contexts.
        
        if (slice->enc_read_ctx == NULL) {
            if ((slice->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
                goto err;
            EVP_CIPHER_CTX_init(slice->enc_read_ctx);
            EVP_CipherInit_ex(slice->enc_read_ctx,c,NULL,key,iv,SSL3_CC_READ);
        }
        
        if (slice->enc_write_ctx == NULL) {
            if ((slice->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
                goto err;
            EVP_CIPHER_CTX_init(slice->enc_write_ctx);
            EVP_CipherInit_ex(slice->enc_write_ctx,c,NULL,key,iv,SSL3_CC_WRITE);
        }
        
        // And the read mac contexts
        
        if (slice->read_mac == NULL) {
            EVP_MD_CTX md;            
            if ((slice->read_mac=malloc(sizeof(SPP_MAC))) == NULL) {
                goto err;
            }
            memset(&(slice->read_mac->write_sequence[0]),0,8);
            memset(&(slice->read_mac->read_sequence[0]),0,8);
            ssl_replace_hash(&slice->read_mac->read_hash,m);
            ssl_replace_hash(&slice->read_mac->write_hash,m);
            memcpy(&(slice->read_mac->write_mac_secret[0]), key, s->s3->write_mac_secret_size);
            memcpy(&(slice->read_mac->read_mac_secret[0]), key, s->s3->read_mac_secret_size);
            
            slice->read_mac->read_hash = EVP_MD_CTX_create();
            slice->read_mac->write_hash = EVP_MD_CTX_create();
        }
    }
    if (slice->write_access) {
        xor_array(slice->write_mat, slice->write_mat, slice->other_write_mat, EVP_MAX_KEY_LENGTH);
        key = &(slice->write_mat[0]);
        
        // Generate the write mac context
        
        if (slice->write_mac == NULL) {
            if ((slice->write_mac=malloc(sizeof(SPP_MAC))) == NULL) {
                goto err;
            }
            memset(&(slice->write_mac->write_sequence[0]),0,8);
            memset(&(slice->write_mac->read_sequence[0]),0,8);
            ssl_replace_hash(&slice->write_mac->read_hash,m);
            ssl_replace_hash(&slice->write_mac->write_hash,m);
            memcpy(&(slice->write_mac->write_mac_secret[0]), key, s->s3->write_mac_secret_size);
            memcpy(&(slice->write_mac->read_mac_secret[0]), key, s->s3->read_mac_secret_size);
            
            slice->write_mac->read_hash = EVP_MD_CTX_create();
            slice->write_mac->write_hash = EVP_MD_CTX_create();
        }
    }
    return 1;
err:
    return -1;
}